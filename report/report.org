#+TITLE:
#+AUTHOR: Bartolomeus Jankowski, Attila Nagy, David Spångberg
#+DATE:
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LATEX_HEADER: \usepackage{fullpage,xcolor,listings, algpseudocode, algorithm, xspace}
#+LATEX_HEADER: \usepackage[style=alphabetic,citestyle=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{references.bib}
#+LATEX_HEADER: \let\iint\relax
#+LATEX_HEADER: \let\iiint\relax
#+LATEX_HEADER: \usepackage{amsmath}

#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc,3d}

#+LATEX_HEADER: \usepackage{alltt}
# #### Palatino font
#+LATEX_HEADER: \usepackage[sc]{mathpazo}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \linespread{1.05} % Palatino needs more leading (space between lines)

#+BEGIN_LATEX
\newcommand{\shrdlite}[0]{\textsc{SHRDLite}\xspace}

\setlength{\parskip}{0.2cm}
\setlength{\parindent}{0pt}
\newcommand{\note}[1]{\emph{\color{blue} Note: #1}}
\newcommand{\todo}[1]{\emph{\color{red} TODO: #1}}
\renewcommand{\ttdefault}{txtt}

\definecolor{lightgrey}{gray}{0.9}
\lstset
{
keywordstyle=\textbf,
numbers=left,
numberstyle=\scriptsize,
frame=l,
numbersep=7pt,
xleftmargin=10pt
}

\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}
\lstloadlanguages{Haskell, Bash, Lisp}
\lstset{
  basicstyle=\small\ttfamily,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em}
 }
\lstnewenvironment{haskell}
    {\lstset{
      literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2
               {\ .\ }{{$\circ$}}2 {\ .\ }{{$\circ$}}2
               {>>}{{>>}}2 {>>=}{{>>=}}2
               {|}{{$\mid$}}1
     }
     \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}

\lstnewenvironment{bash}
    {\csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}
#+END_LATEX

\thispagestyle{empty}

\begin{centering}
\includegraphics[width=11cm]{gu.eps} \\
\vspace{1cm}
\includegraphics[width=5cm]{chalmers.eps}
\vspace{5cm}

\huge
Controlling a \shrdlite robot \\ using Haskell
\\\Large \vspace{0.5cm} Group 14

\vspace{0.5cm}
\normalsize
\end{centering}

# The hspace is a hack to align the table a little more to the right.
# I.e. to move the vertical bar closer to the middle of the page.
| /               |                   <r> |                                   |
| /               |                     > |                                   |
| \hspace{0.25cm} | Bartolomeus Jankowski | \texttt{<brtk666@gmail.com>}      |
|                 |           Attila Nagy | \texttt{<attilanagy85@gmail.com>} |
|                 |       David Spångberg | \texttt{<david@tunna.org>}        |
\newpage

\pagenumbering{roman}

#+BEGIN_LATEX
$~$
\vspace{4.3cm}

\section*{Abstract}
\smallskip
  Automated planning and scheduling have many obvious application in real-life
  areas of business. One such imaginable planner, is one that arranges a set of
  objects in an abstract \emph{world} that perhaps models a factory floor or a
  harbor loading area where the task is to move specific cargo crates from one
  spot to another.

  Here a simplified version of such a planner is implemented, the most important
  simplifications being that dimensions of the world are restricted to two and
  that while the commands to the planner are given in plain English, the
  grammar that the scheduler is able to parse is quite simple.

  The application is inspired by the much more complex system described in Terry
  Winograd's PhD thesis \cite{win1970shrdlu}.

\noindent \textbf{Keywords: Automated planning, SHRDLU, PDDL, STRIPS}

\addcontentsline{toc}{section}{Abstract}
#+END_LATEX

\newpage
[TABLE-OF-CONTENTS]
\newpage

\pagenumbering{arabic}

* Introduction and Background
  This section gives an overview about the problem itself and describes the
  algorithms, theorems and tools that were used during this project.
  Furthermore, this section presents several alternative solutions for the
  given problem, that were not used in the final solution, but took part in
  the development process.

** Problem description
   \label{sec:problem}

   The problem consists of the implementation of planner for a robot arm in a
   two-dimensional \shrdlite virtual world. This robot arm can only pick up or
   drop an element at the same time.  The planner's task is to determine a
   sequence of the pick and drop commands that leaves the virtual world in
   the required state defined by the user.

   The block elements have several properties, such us: form, color, size, width
   and height. Depending on these properties, several rules exist that exclude
   certain combinations of stacked objects. For instance, a block cannot be
   placed on another block if it is greater than the other block, or nothing can
   be placed on a ball or pyramid. Besides blocks, there is a floor in the world
   which cannot be moved and nothing can be placed below it.

   The elements and their positions in the initial world state are chosen
   arbitrarily and hard-coded in the system. This initial state can be set to
   any preferable state.

   A command given by the user is first parsed by a grammar interpreter, called
   GF. Then, before feeding the result to the planner, it must be converted to a
   form that is compatible with the planner. In our case it is written in
   Planning Domain Definition Language. Finally, the planner gives back a list
   of pick and drop commands that provide the transition between the current and
   goal state.

** Related work
   The two-dimensional world described above is much simplified version
   of a three-dimensional block world implemented by Terry Winograd in late
   1960s and described in his dissertation \cite{win1970shrdlu}.

   Winograd's, at its time pioneering planner called SHRDLU, demonstrated
   interaction between the user and the system using simple English phrases. The
   domain was three-dimensional world populated by several different object that
   could be arranged by the system as instructed by the user. It was also able
   to answer simple questions about the world such as "What does the green box
   contain?" and memorize names of the world's elements or simple facts such
   about the user, provided that the user informed the system about these facts
   before hand.

   SHRDLU in action can be seen in Figue \ref{fig:shrdlu3d} and in the video
   [fn:3] available on-line (ca. 6 min).

   \begin{wrapfigure}[14]{r}{3.0in}
      %\begin{minipage}[c]{\textwidth}
      \centering
          \includegraphics[width=3in]{./images/shrdlu_3d.png}
          \caption{The original SHRDLU in action, running on PDP-6 computer.}
          \label{fig:shrdlu3d}
      %\end{minipage}
    \end{wrapfigure}

   In some aspects the two-dimensional problem described here is reminiscent to
   the well-known problem called \textsc{Towers Of Hanoi}, where the user is
   supposed to move a number of disks according to some natural rules. This
   problem can often be solved by Automated Planners, one such planner being FF
   described below:

   \textsc{Fast Forward Planner} (FF) \cite{ffPlanner1} is another planner
   worth mentioning here. It is a domain independent planning system handling
   STRIPS planning tasks (that can also be extended with \emph{equality}
   operator and \textsc{Action Description Language} (ADL)), used here to
   generate intermidiate steps in the problem solution.

** Available tools
   During the implementation of the planner described here, several tools and
   libraries were taken into consideration as possible aids or components of
   \shrdlite. Some of these libraries were used and other are perhaps intended
   as future work.

   One possibility of solving a planning problem is to encode it into a language
   of \emph{First Order Logic} (FOL) and then solve, using any appropriate FOL-
   theorem prover. One of more known such provers is \emph{E-Prover} originally
   developed by Stephan Shultz \cite{e-prover}. Some simple tests showed
   however, that it is seemingly slow and more importantly, it generates large
   solution paths even for simple problems. As the consequence, E-Prover was not
   used in the project but perhaps should be examined more thoroughly in the
   future, see Section \ref{sec:future-fol}.

   Another suitable usable language that is directly aimed at planning problems
   is \emph{STRIPS}. The language has its roots in an automated planner with the
   same name, developed in early 1970's, where it also was used to model the
   problem. \emph{PDDL} is more recent attempt to standardize description of
   domain and planning problems and is a subset of STRIPS. Fast Forward planner
   mentioned above uses PDDL as input, therefore the domain and problems were
   modelled using this language.

   The PDDL input consists here of two parts: domain description and problem
   description.
   - *Domain Description* contains definitions of possible predicates on
     objects populating the world as well as all possible actions that can be
     taken to alter the world. Each action specifies a set of
     \emph{precondititions} that must hold before the action in question can be
     taken, together with a set of \emph{postconditions} that are assigned to be
     true after the action has been taken. In some sense the domain defines a
     global state and a set of methods that can alter it.

   - *Problem Description* consists of an initial state definition of the world
      and the desired end state, often called *goal state*. The state is simply
      a set of predicates on world that hold at this state.

   If the problem is solvable, the expected output is a list of actions taken to
   reach goal state.

   To be able to construct the goal, it is required to extract and interpret
   information contained in user-provided commands. An asset used to accomplish
   that was the Grammatical Framework, described in more detail in Section
   \ref{sec:parsing}.

* Overview of the architecture
   This section describes the parts of the project that has been finished,
   currently under development, or just an idea waiting to be implemented.
   Section \ref{sec:finished} shows a detailed view about the current design
   including the structure of the domain and problem file written in PDDL,
   the code level representation of the world, the goal creation process and
   the interpretation of the parsed grammar tree. Section \ref{sec:progress}
   mainly contains the user commands that do not work as expected and,
   therefore, these cases are still under investigation. Finally, Section
   \ref{sec:future} mentions some of the possibilities for further development.

** Finished work
   \label{sec:finished}

   On a very high level, the implementation consists of three parts:
   - Parsing and simplifying a natural language command from the user
     using /GF/ \cite{gf}.
   - Transforming a world state and a simplified command into a goal
     and then transforming the same world state and goal into a
     /PDDL/-problem.
   - Using the /metric-ff/ planner to extract a plan for the given
     problem.
   In addition to a small introduction of s-expressions, the following
   sections will examine our solutions for each of the problems above
   in detail.

*** S-expressions
    \label{sec:sexpr}

    Since the user command returned from GF was serialized to an
    s-expression, a small module was made to parse and process such
    expressions. Traditionally an s-expression can be describe by the
    following inductively defined data type:

    - An /atom/ is an s-expression
    - If =x= and =y= are s-expressions, then so is =(x . y)=

    In the s-expression module an atom is defined as either the nil
    atom /()/ or a list of characters not including any parenthesis,
    semicolons or double quotation marks. In most instances, which is
    the case of the GF output, s-expressions lists are written without
    dots between elements. The list =(a b c d)= should then be
    interpreted as =(a.(b.(c.(d.()))))= or =(a.b.c.d.())=.

    Finally the implemented s-expression data type assumes that all
    lists are sound; there cannot be lists where the second element
    after the dot isn't a list, i.e. =(a.b)= is not considered to be a
    valid s-expression. This makes both working with and parsing
    s-expressions easier.

*** Parsing
    \label{sec:parsing}

    The Grammatical Framework plays a vital role in this project. It parses the
    command given by the user and builds a tree structure for the planner. For
    the representation of this tree, a tree-structured nested data list, called
    s-expression, was used. Its implementation is relatively simple and
    described in details in section \ref{sec:sexpr}.

    The structure of the parse tree is represented by the following
    Backus–Naur Form:

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{alltt}
    \textbf{Command} ::= "take" Thing
              | "put"  Location
              | "move" Thing Location

    \textbf{Location} ::= "beside" Thing
               | "leftof" Thing
               | "rightof" Thing
               | "above" Thing
               | "ontop" Thing
               | "under" Thing
               | "inside" Thing

    \textbf{Thing} ::= "the" Block
            | "any" Block
            | "all" Block
            | "floor"

    \textbf{Block} ::= "block" Form Size Color
            | "thatis" Block Location
\end{alltt}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
\begin{alltt}
    \textbf{Size} ::= "anysize"
           | "small"
           | "medium"
           | "large"
           | "wide"
           | "tall"

    \textbf{Color} ::= "anycolor"
            | "black"
            | "white"
            | "blue"
            | "green"
            | "yellow"
            | "red"

    \textbf{Form} ::= "anyblock"
           | "box"
           | "pyramid"
           | "rectangle"
           | "square"
           | "ball"
\end{alltt}
\end{minipage}
\caption{BNF of the user command language}
\end{figure}

    This bnf form tells all possible combinations of words that were
    produced by the Grammatical Framework and the problem generator must
    be able to interpret.

*** Goal/Problem generation
    \label{sec:goal-gen}

#    \todo{latex doesn't like labels for subsubsubsections. Either
#    remove the section references or try to fix somehow.}

    In this section the main task of the project is tackled, namely
    generating a goal and problem description from a user command. The
    first problem is to identify all blocks and relative locations
    that the user talks about have in the current world. This is
    discussed in section \ref{sec:finding}. The next step, discussed
    in section \ref{sec:goals}, is the process of generating a goal
    representing the intention of the user command. When a goal has
    been found the current state of the world together with the goal
    has to be encoded into a representation understood by the planner.
    Section \ref{sec:domain} discusses how the world and the possible
    actions in the world is encoded using predicates in a specific
    domain file. Finally section \ref{sec:gen-problem} discusses how
    the world is finally encoded using these predicates.

**** Finding Things, Blocks and Locations
     \label{sec:finding}

     $~$

     There are three basic types in the \shrdlite world: /things/,
     /blocks/ and /locations/. A thing is one or many blocks or the
     floor. A block is a either a description of a block consisting of
     a form, a size and a color or a block paired with a location. A
     location is a relative placement description, i.e.
     \hbox{\emph{"left of"}/\emph{"above"}} etc, paired with a thing.
     As an example lets look at the following command string and its
     resulting s-expression after being parsed by GF: $$\text{"the
     white block to the left of any red square"} \Longrightarrow$$
     $$\texttt{(the (thatis (block \_ \_ white) (leftof (any (block
     square \_ red)))))}$$ /the/ is one of the constructors to lift a
     block into a thing[fn:1]. /thatis/ is the constructor which takes
     a block and a location and produces a new block. To find all
     things which matches this description the complete s-expression
     is sent to =findThings=. Since the constructor =the= is used
     there must also be a block description which is sent to
     =findBlocks=.
\begin{haskell}
findBlocks :: World -> SExpr -> [(Col, Thing)]
findBlocks world (List [Atom "thatis", blockDescr, locDescr]) = intersect blocks locs
  where
    blocks = findBlocks world blockDescr
    locs   = findLocations world locDescr
findBlocks world (List [Atom "block", Atom form, Atom size, Atom color]) =
    map (second TBlock) . formFilter . sizeFilter . colFilter $ allBlocks
  where
    allBlocks = getBlocks world
    ...
\end{haskell}
     In this function we find that the top most constructor used is
     =thatis= and we must therefore also have one more block- and
     location description. Recursively calling =findBlocks= with the
     block description =(block _ _ white)= returns all white blocks in
     the current world. Now =findLocations= is called with =(leftof
     (any (block square _ red)))= finding all things which matches
     this particular location description. Finally the intersection of
     the results from the recursive call and the call to
     =findLocations= is the final result of this particular call to
     =findBlocks=.

     As an example consider the case when the parse tree mentioned
     above is given to =findThings= in the world seen in figure
     \ref{fig:shrdlite-small}.

     #+CAPTION: Small \shrdlite world with four different blocks.
     #+LABEL: fig:shrdlite-small
     #+ATTR_LATEX: scale=1
     [[./images/smallworld.png]]

     1. =findThings= will only remove the "the" from the parse tree and
       call =findBlocks= with the rest of the tree.
     2. =findBlocks= will recursively call itself with =(block _ _
        white)= and =findLocations= with =(leftof (any (block square _
        red)))=.
        1. =findBlocks (block _ _ white)= will return the two white
           blocks in the world.
        2. =findLocations (leftof (any (block square _ red)))= will
           call =findThings (any (block square _ red))= which in turn
           will return the large red square. Now since the constructor
           used to create the location description is =leftof= all
           things in the world to the left of the returned red block
           will be returned, in this case the white ball and the blue
           rectangle and also two /floor tiles/ will be returned, one
           floor tile right below the two blocks and one tile on the
           empty space to the left of these blocks. The floor tiles
           can be seen as immovable blocks at the bottom of every
           column in the world.
        3. Now finally the intersection of =findBlocks= and
           =findLocations= is the returned value for the top most
           =findBlocks= call. This intersection will contain a list of
           exactly one element, namely the white ball.

     Finally the last function that needs to be explained is
     =findLocations=.

\begin{haskell}
findLocations :: World -> SExpr -> [(Col, Thing)]
findLocations world (List [Atom loc, thingDescr]) =
    let things = findThings world thingDescr
        Atom s = car thingDescr
    in case loc of
        ...
        "leftof"  -> let maxIdxFun = if s == "all" then minimum else maximum
                         idxs   = [0 .. maxIdxFun (map fst things)]
                     in concatMap (allThingsAtCol world) idxs
        ...
\end{haskell}

     At line 3 =things= will be bound to the list of things which
     matches the current thing description. Line 7 to 9 shows the
     particular case when we want to return things to the left of all
     or any of the returned things. When /all/ is used in
     =thingDescr=, the minimum column number is taken from column
     indexes in =map fst things=. If /any/ or /the/ is used than the
     maximum column index is returned instead.[fn:2]

**** Finding goals
     \label{sec:goals}

     $~$

     The implementation of the goal finding functions closely follows
     the structure of the \shrdlite grammar mentioned in the previous
     section. A parse tree from a user command start with either a
     =take=, =put= or =move= atom where the first two commands has
     exactly one argument, a thing- or a location-description
     respectively. The =move= command is a bit more powerful and takes
     both a thing- and location-description as arguments. The function
     =tryGoal= only matches this first command token and delegates the
     responsibility of producing a goal to =tryTake=, =tryPut= or
     =tryMove= respectively. Below =tryMove= is examined since this is
     enough to understand the implementation of the other two
     functions.
\begin{haskell}
tryMove :: SExpr -> Reader State (Maybe Goal)
tryMove (List [src, List [Atom loc, dst]]) = do
    (_,world) <- ask
    let s = findThings world src
        d = findThings world dst
        qSrc = getQuantifier src
        qDst = getQuantifier dst
        goalList f = [(qSrc (map (thingToBlock . snd) s), qDst (map (f . snd) d))]
    return $ Just $ case loc of
        "beside"  -> defaultGoal { getBeside  = goalList thingToBlock }
        ...
        "inside"  -> defaultGoal { getIn      = goalList thingToBlock }
\end{haskell}
     The sole argument to =tryMove= is an s-expression list containing
     exactly two elements, a thing description and a location
     description. On line 4 =s= will be a list of all things in the
     current world matching the thing description found in =src=. On
     the next line =d= will be a list of all things matching the thing
     description =dst=. Note that we are only interested in finding
     the things matching the thing description (=dst=) of the location
     description (=List [Atom loc, dst]=) and not the things that
     matches the whole location description. This is the case since
     the relative position to any of the things matching =dst= is
     directly encoded in the =Goal= data type using one of the fields
     of the data type as can be seen on lines 10 through 16. Finally
     =getQuantifier= is used to get the quantifier used in the
     construction of the goal.
\begin{haskell}
getQuantifier :: SExpr -> [a] -> Quantifier a
getQuantifier q = case q of
    List (Atom "the" : _) -> \[x] -> The x
    List (Atom "all" : _) -> All
    -- This matches any and floor
    _                     -> Any
\end{haskell}
     Basically =getQuantifier= returns the quantifier used in the user
     command. I.e. if the original command was "put any block on the
     floor" then the quantifier returned would be =Any=.

**** Shrdlite PDDL domain
     \label{sec:domain}

     $~$

     The \shrdlite domain and the possible actions that can be
     performed in this domain is expressed in a =PDDL= domain file
     which can be seen in appendix \ref{sec:shrdlite-dom}. This file
     contains two things: predicates with zero or more arguments
     specifying properties of the objects in the world, and actions
     defining all available operations on objects. The actions are
     used to change one or more properties of a object, while the
     predicates can be used as preconditions to actions and also for
     specifying goal states.

\begin{lstlisting}[language=lisp, caption=The action \texttt{set-inside} as defined in the \shrdlite domain file., label=lst:set-inside]
;; `x' is inside `box' if `y' is inside `box' and `x' is on `y'
(:action set-inside
 :parameters   (?x ?y ?box)
 :precondition (and (inside ?y ?box)
                    (on ?x ?y))
 :effect       (and (inside ?x ?box)
                    (frozen ?x)))
\end{lstlisting}

     Listing \ref{lst:set-inside} shows the action =set-inside= as
     specified in the domain file. It takes three parameters =?x, ?y=
     and =?box=, has some preconditions which must be satisfied to be
     able to use this action. Finally it has an effect specifying that
     =?x= is inside the box =?box= and that =?x= is frozen. The
     special predicate =frozen ?x= specifies that the object =?x=
     cannot be moved anymore and is used to simplify the definitions
     of other actions.

     The main actions in the domain file is the =pick= and =drop=
     commands that lifts up a block or puts it down on either another
     block or the floor.

**** Generating a PDDL problem
     \label{sec:gen-problem}
     $~$

     The last step before handing over the responsibility to the
     planner is to generate a =PDDL= problem file. This file contains
     the initial or current state of the world encoded using the
     predicates found in the \shrdlite grammar in appendix
     \ref{sec:shrdlite-dom}. A high level description of the \shrdlite
     world can be found in \ref{sec:problem}. More detailed the
     problem file initially defines the following properties for the
     objects in the world:

     - \setlength{\itemsep}{0cm} =smaller x y=: All blocks are smaller
       than the floor and some objects are smaller than other objects.
       This predicate defines that it is possible to place the =x= on
       =y=. For example since nothing can be placed on balls then
       nothing is smaller than any ball.
     - =frozen f=: All floor tiles are frozen and cannot be moved.
     - =clear x=: Things at the top of each stack including the floor
       is clear.
     - =inside x y=: In the initial state only boxes are inside
       themselves.
     - =on x y=: If block =x= is placed on top of thing =y= then =x=
       is on =y=.
     - =above x y= / =under x y=: In the initial state all things
       are above and under themselves.
     - =leftof x y= / =rightof x y= / =beside x y=: The floor tiles
       are left-of, right-of and beside other floor tiles. The
       difference by being beside and for instance left-of is that a
       thing has to be directly left-of another thing to be considered
       beside it.
     - =stacked-on x c=: All blocks are stacked above some floor tile
       (column =c=). The floor tiles are also stacked on themselves.

     The predicates above specifies the initial state of the problem.
     Whats left to do is encode the goal state of the problem given a
     value of type =Goal=.

\begin{haskell}
data Goal = G
    { getOn          :: [(Quantifier Block, Quantifier Thing)]
      ...
    , getBeside      :: [(Quantifier Block, Quantifier Block)]
    , getHolding     :: [Block]
    }
\end{haskell}

     The goal data type contains fields for all of the different types
     of commands that can be given, for instance that a block should
     be beside, left-of or above one, any or several other object. The
     goal that the block =a= should be right-of any of the blocks =b=,
     =c=, and =d= will be encoded in the following way:

\begin{haskell}[caption=test]
defaultGoal { getRightOf = [(The a, Any [b,c,d])] }
\end{haskell}

     For each quantifier pair in all of the lists in the goal data
     type, a subgoal will be generated. Each of these subgoals is then
     joined by a large conjunction. For example the pair above will be
     exported to the following subgoal:

\begin{lstlisting}[language=bash, caption=Resulting subgoal of \texttt{(The a, Any [b,c,d])}, label=lst:subgoal]
(or (and (right-of a b) (above b f1))
    (and (right-of a c) (above c f2))
    (and (right-of a d) (above d f2)))
\end{lstlisting}

     Listing \ref{lst:subgoal} shows the subgoal generated from the
     simple goal further above. A =right-of= predicate is generated
     for each combination of elements from the first and second
     quantifier. The predicates will be joined together using either
     disjunctions, conjunctions or both depending on the quantifier
     types used. Finally for each predicate an =above x f= predicate
     will be added to specify that all objects found in the second
     element of the pair should be present at the same column as in
     the initial state. Adding this last predicate is usually the
     right thing to do to make the planner behave in the way a user
     intended. However, this will not always be correct. To see this
     lets consider two different commands in the world seen in figure
     \ref{fig:world2}.

     #+CAPTION: A \shrdlite world featuring several blocks.
     #+LABEL: fig:world2
     #+ATTR_LATEX: placement=[H] width=14cm
     [[./images/smallworld2.png]]

     First let the first user command be "Move all red blocks to the
     left of the tall blue block". This problem can be trivially
     solved by a planner by moving the tall blue block to the right of
     all red blocks, never moving the red blocks at all. This is
     probably not what the user intended. However by enforcing all red
     blocks to be above the same column at the end of the plan then
     the only way to solve this problem is to actually move all red
     blocks to the left of the initial position of the tall blue
     block.

     Now lets consider the following command in the same world: "Put
     the yellow pyramid above all red blocks". The only way to solve
     this problem is to stack the two red objects in the world on top
     of each other and then moving the yellow pyramid on top of the
     stack. Adding the =above= rule, which is done in our problem file
     generation, actually inhibits us to solve the problem; you cannot
     place the pyramid above both red blocks since they have to be on
     different columns!

*** Finding a plan
    \label{sec:planning}
    After having the problem file, the planner is fed with this file along
    with the domain file. These files were described in details in
    section~\ref{sec:goal-gen}, and, therefore, they are not covered here again.
    As for the planner, two distinct implementation of the fast forward
    planner were tested. First, the simple fast forward planner \cite{ff} was
    used, but after a few tests on metric-ff \cite{metric-ff}, the simple ff was
    not used anymore due to its five times slower planning time.

    The plan contains a list of pick and drop commands which can contain extra
commands that are irrelevant in the plan. Such command can be for instance a
pair of consecutive pick and drop commands on the same column. By removing these
extra steps in the plan, a shorter and more optimal plan can be gained. This
process is called pruning. This is done by the following code:

\begin{lstlisting}[language=Haskell,escapechar=@]
planFromFF :: String -> IO [String]
planFromFF problem = withSystemTempFile "shrdlu.problem." $ \fp h -> do
    hPutStr h problem
    hClose h
    let ff = "../bin/ff-wrapper.sh"
        args = [fp]
    (exitCode, out, err) <- readProcessWithExitCode ff args ""
    let getNum = read . (!!1) . words :: String -> Int
        moves  = lines out
        @\textbf{prune}@ [] = []
        @\textbf{prune}@ [x] = [x]
        @\textbf{prune}@ (x:y:xys)
            | getNum x /= getNum y = x : prune (y:xys)
            | otherwise            = prune xys
    if exitCode == ExitSuccess
        then return (@\textbf{prune}@ moves)
        else return $ ["# Got an error!"])
\end{lstlisting}

The planner is called from a wrapper shell script, called ff-wrapper.sh". It
runs the 'ff' binary with the domain and problem files, check if there was any
error, and parses the output.

\begin{bash}
domain="../planner-haskell/resources/shrdlu-dom.pddl"
problem_file=$1

# run planner
ff_out=$(../bin/ff -o $domain -f $problem_file -s 5)

# error checking
if [[ $? != 0 ]] ; then
    echo "Some error occured. Output from ff:"
    echo ""
    echo "$ff_out"
    exit 1
fi

# parsing
actions=$(echo -e "$ff_out" | egrep -i "(PICK|DROP)")
echo "$actions" | cut -b 12- | sed -re 's/^(PICK|DROP).*F(\w*)$/\L\1 \2/i'
\end{bash}

** Work in progress
   \label{sec:progress}
   Here, some parts that are still under development are touched upon.

*** Bug corrections
    \label{sec:bugs}

    Currently there are some bugs in =findLocations= which were
    discovered while writing the report. Some of them were fixed
    before submitting the final version but some remains. One of the
    bugs is when calculating the things returned when the relative
    placement word is "beside" as in the command: "pick up any block
    beside all red blocks". In natural language this sentence doesn't
    look right but makes sense if all red blocks are one the same
    column are separated by exactly one space. The problem is that the
    current implementation assumes that "any" is used instead of "all"
    as in the sentence above. In the "any" case all blocks beside any
    red block would be returned while in the "all" case only the
    blocks that are beside all red blocks at the same time would be
    returned.

*** Plan-pruning
    \label{sec:plan-purning}
    It can happen that the planner does not produce a perfect plan. Several
    consecutive states end up in a state that was reached earlier. In this case
    these steps are superfluous and can be removed.

    A basic form of this pruning was implemented in the current project which
    can be further improved. Currently it only checks if consecutive pick and
    drop commands happen on the same column. The more advanced form of this
    pruning would be to go through the whole list of commands and check if the
    world state that this command leads to was reached earlier. If it was, then the
    list of commands can be deleted back to this earlier state. For instance,
    the 'A -> B -> ... -> B' list of states can be reduced to 'A -> B'.

*** First Order Logic
    \label{sec:future-fol}
    After some fruitless experimentation with a FOL theorem prover, namely
    E-prover, metric-ff was chosen for planning. This decision was based on its
    significantly higher running time and hardship of goal interpretation.
    However, in the long run E-prover might produce more appealing results with
    a simpler problem description form.

** Future work
   \label{sec:future}

   This section mentions a subset of the viable additions for the
   project which might further increase its usability.

*** Generating FOL to STRIPS
    \label{sec:fol_to_strips}
    Another possible solution for planning can be to merge FOL with STRIPS
    combining their positive features. By this, a planner can be gained that is
    endowed by easy goal generation and openness for future grammar extensions.
    Unfortunately, there was no time for such experimentations, and, therefore,
    it remained only an idea.

*** Other planners
    There are many other planners and planning algorithms besides the
    ones discussed so far. Any number of these planners can be tried
    out or implemented and eventually benchmarked against each other
    in terms of running time and solution length.

* Results and Evaluation
  \label{sec:results}
   This chapter will present problems from the laboratory description and
   problems that required extra effort during
   implementation. Moreover, in section \ref{sec:non_working}, problems, not solved correctly due to their
   complexity and the lack of time spent on implementation, are presented.
   All of the user commands for these problems were executed from the same
   initial state, depicted by picture \ref{fig:init_state}.
** Problems with solution
   Table \ref{tab:working_problems} contains the planning time and command list
   length for the user commands that produce the expected result.
#+CAPTION: Initial state of the \shrdlite world
#+LABEL: fig:init_state
#+ATTR_LATEX: placement=[h] scale=0.5
[[./images/initial.png]]

#+CAPTION: Problems with working solutions
#+LABEL:   tab:working_problems
| User Command                                             | Planning | Command List |
|                                                          | Time     | Length       |
|----------------------------------------------------------+----------+--------------|
| Pick up a big red block                                  | 0.613s   | 3            |
| Grasp the green pyramid                                  | 0.636s   | 2            |
| Put it in a box                                          | 0.642s   | 1            |
| Put a ball that is to the left of a pyramid inside a box | 0.679s   | 4            |
| move all red boxes inside the white box                  | 1.394s   | 18           |
| move all red blocks to the left of the tall blue block   | 1.550s   | 22           |
| put all red blocks in the white box                      | 15.478s  | 42           |


Putting all red blocks in the white box is a relatively hard problem, since
it needs 42 steps to be solved. On the other hand, its planning time is still manageable.
Furthermore, commands requiring less than 25 steps are most of the time solved almost
instantly. According to our experimentations, most of the sensible commands
can be solved in less than 25 steps, which provides a pleasant user experience.

** Problems without working solution
   \label{sec:non_working}
   - /put the yellow ball above all red blocks:/ \\
     This problem is not executable since there is a rule that makes all red
     blocks to stay at their current position. However, the user's intention
     would be to stack all red blocks in one column and move the yellow
     ball on the top of this stack. This problem was discussed in more detail at the
     end of section \ref{sec:gen-problem}.
   - /pick up the yellow pyramid above all red blocks:/\\
     The current implementation picks up a yellow pyramid that is on a red
     block. However, the expected result is to pick up the yellow pyramid that
     is above all red blocks. To achieve this, all red blocks must be
     in one column, and the yellow pyramid must be above all of these red
     blocks.

* Discussion
  \label{sec:discussion}

  In this project we implemented an automated planner for the
  \shrdlite world. Several impediments had to be overcome, for
  instance: constructing the correct goal from a user command or
  encoding the world in =PDDL=. Our implementation works sufficiently
  well, enough to solve fairly complicated problems, always producing
  short plans.

  There are several ways to extend the project, we think that the most
  exiting one is to use quantification in the goal description instead
  of enumerating all blocks matching the current criteria. In our
  opinion, any extension should be reasonably simple given that the
  project size is relatively small and that the code should be simple
  to follow.

# TODO Remove this later
# \nocite{*}

\printbibliography

\appendix

\addcontentsline{toc}{section}{Appendix}

\newpage

* SHRDLite PDDL domain file
  \label{sec:shrdlite-dom}

  \vspace{1cm}

\begin{haskell}
(define (domain shrdlu)
  (:functions (moves))

  (:predicates (clear ?x)          ;; 'x' is top-most block
               (on ?x ?y)          ;; 'x' is on top of 'y'
               (box ?x)            ;; 'x' is a box
               (inside ?x ?y)      ;; 'x' is inside box 'y'
               (smaller ?x ?y)     ;; 'x' is smaller than 'y'
               (stacked-on ?x ?c)  ;; 'x' is stacked on column 'c'
               (holding-any)       ;; the arm is holding something
               (holding ?x)        ;; 'x' is up in the air
               (frozen ?x)         ;; 'x' is frozen and cant be moved
               (above ?x ?y)       ;; 'x' is somewhere above 'y'
               (under ?x ?y)       ;; 'x' is somewhere under 'y'
               (left-of ?x ?y)     ;; 'x' is somewhere left of 'y'
               (right-of ?x ?y)    ;; 'x' is somewhere right of 'y'
               (beside ?x ?y))     ;; 'x' is directly beside 'y'

  (:action pick
   :parameters (?obj ?from ?col)
   :precondition (and (not (frozen ?obj))
                      (not (holding-any))
                      (clear ?obj)
                      (on ?obj ?from)
                      (stacked-on ?obj ?col))
   :effect       (and (holding-any)
                      (holding ?obj)
                      (clear ?from)
                      (not (on ?obj ?from))
                      (not (stacked-on ?obj ?col))
                      (increase (moves) 1)))

  (:action drop
   :parameters (?obj ?to ?col)
   :precondition (and (holding ?obj)
                      (clear ?to)
                      (smaller ?obj ?to)
                      (stacked-on ?to ?col))
   :effect       (and (not (holding-any))
                      (not (holding ?obj))
                      (not (clear ?to))
                      (on ?obj ?to)
                      (stacked-on ?obj ?col)
                      (increase (moves) 1)))
  ;; 'first' is above both 'second' and 'under' if 'second' is above 'under' and 'first'
  ;;  is on 'second'
  (:action set-above
   :parameters (?first ?second ?under)
   :precondition (and (on ?first ?second)
                      (above ?second ?under))
   :effect       (and (above ?first ?second)
                      (above ?first ?under)
                      (frozen ?first)))

  ;; Set a flag that a 'first' is below or under 'second' and 'above'
  (:action set-under
   :parameters (?first ?second ?above)
   :precondition (and (on ?second ?first)
                      (under ?second ?above))
   :effect       (and (under ?first ?second)
                      (under ?first ?above)
                      (frozen ?above)))

  ;; `x' and `y' are left- and right of each other if `x' is stacked on a floor column
  ;; to the left of `y'
  (:action set-left-right
   :parameters (?x ?y ?left-floor ?right-floor)
   :precondition (and (stacked-on ?x ?left-floor)
                      (stacked-on ?y ?right-floor)
                      (right-of ?left-floor ?right-floor))
   :effect       (and (right-of ?x ?y)
                      (left-of  ?y ?x)
                      (frozen ?x)
                      (frozen ?y)))

  ;; `x' and `y' are beside each other if `x' is stacked on a floor column beside of `y'
  (:action set-beside
   :parameters (?x ?y ?left-floor ?right-floor)
   :precondition (and (stacked-on ?x ?left-floor)
                      (stacked-on ?y ?right-floor)
                      (beside ?left-floor ?right-floor))
   :effect       (and (beside ?x ?y)
                      (beside ?y ?x)
                      (frozen ?x)
                      (frozen ?y)))

  ;; `x' is inside `box' if `y' is inside `box' and `x' is on `y'
  (:action set-inside
   :parameters (?x ?y ?box)
   :precondition (and (inside ?y ?box)
                      (on ?x ?y))
   :effect       (and (inside ?x ?box)
                      (frozen ?x))))
\end{haskell}

* Individual stories
** Attila Nagy
   Code:
   - move command

   Report:
   - Section \ref{sec:problem}
   - Section \ref{sec:parsing}
   - Section \ref{sec:planning}
   - Section \ref{sec:plan-purning}
   - Section \ref{sec:future-fol}
   - Section \ref{sec:fol_to_strips}
   - Section \ref{sec:results}

** David Spångberg
   Code:
   - =SExpr= module
   - Work in =Types=, =Utils= and =World= modules
   - General work in =Planner= module

   Report:
   - Parsing \ref{sec:parsing}
   - Goal generation \ref{sec:goal-gen}
   - S-expressions \ref{sec:sexpr}
   - Bug corrections \ref{sec:bugs}
   - Discussion \ref{sec:discussion}

   Other:
   - Experimentation with eprover

** Bartolomeus Jankowski

   Code:
   - findLocations in Planner.hs
   - PDDL domain file

   Report:
   - Abstract
   - Related Works
   - Available Tools
   - Discussion \ref{sec:discussion}

   Other:
   - some initial research on Fast-Forward planner

* Footnotes

[fn:1] The other two are /any/ and /all/.

[fn:2] If /the/ is used then =things= will have exactly length one and
it doesn't matter if we use =minimum= or =maximum=. However if we have
something like =(leftof floor)=, which is valid according to the
grammar, then this will currently result in a pattern match error on
line 4. To fix this the return type of =findLocations=, and
consequently the return type of all =find*= functions, can for
instance be changed to =Error [(Col, Thing)]= and then a descriptive
error message can be returned instead.

[fn:3] [[http://projects.csail.mit.edu/video/history/aifilms/26-robot.mp4]]
