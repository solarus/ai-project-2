#+TITLE:
#+AUTHOR: Bartolomeus Jankowski, Attila Nagy, David Spångberg
#+DATE:
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LATEX_HEADER: \usepackage{fullpage,xcolor,listings, algpseudocode, algorithm}
#+LATEX_HEADER: \usepackage[style=alphabetic,citestyle=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{references.bib}
#+LATEX_HEADER: \let\iint\relax
#+LATEX_HEADER: \let\iiint\relax
#+LATEX_HEADER: \usepackage{amsmath}

#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc,3d}

# #### Palatino font
#+LATEX_HEADER: \usepackage[sc]{mathpazo}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \linespread{1.05} % Palatino needs more leading (space between lines)

#+BEGIN_LATEX

\setlength{\parskip}{0.2cm}
\setlength{\parindent}{0pt}
\newcommand{\note}[1]{\emph{\color{blue} Note: #1}}
\newcommand{\todo}[1]{\emph{\color{red} TODO: #1}}

\definecolor{lightgrey}{gray}{0.9}
\lstset
{
keywordstyle=\textbf,
numbers=left,
numberstyle=\scriptsize,
frame=l,
numbersep=7pt,
xleftmargin=10pt
}

\lstloadlanguages{Haskell}
\lstnewenvironment{haskell}
    {\lstset{}%
      \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}
    \lstset{
      basicstyle=\small\ttfamily,
      flexiblecolumns=false,
      basewidth={0.5em,0.45em},
      literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2
               {\ .\ }{{$\circ$}}2 {\ .\ }{{$\circ$}}2
               {>>}{{>>}}2 {>>=}{{>>=}}2
               {|}{{$\mid$}}1
    }
#+END_LATEX

\thispagestyle{empty}

\begin{centering}
\includegraphics[width=11cm]{gu.eps} \\
\vspace{1cm}
\includegraphics[width=5cm]{chalmers.eps}
\vspace{5cm}

\huge
Controlling a Shrdlite robot \\ using Haskell
\\\Large \vspace{0.5cm} Group 14

\vspace{0.5cm}
\normalsize
\end{centering}

# The hspace is a hack to align the table a little more to the right.
# I.e. to move the vertical bar closer to the middle of the page.
| /               |                   <r> |                                   |
| /               |                     > |                                   |
| \hspace{0.25cm} | Bartolomeus Jankowski | \texttt{<brtk666@gmail.com>}      |
|                 |           Attila Nagy | \texttt{<attilanagy85@gmail.com>} |
|                 |       David Spångberg | \texttt{<david@tunna.org>}        |
\newpage

\pagenumbering{roman}

#+BEGIN_LATEX
$~$
\vspace{4.3cm}

\section*{Abstract}
\smallskip
  Automated planning and scheduling have many obvious application i real-life
  areas of bussiness. One such imaginable planner, is one that arranges a set of
  objects in an abstract \emph{world} that perhaps models a factory floor or a harbor
  loading area where the task is to move specific cago crates from one spot to
  another.

  Here a simplified version af such a planner is implemented, the most important
  simplifications being that dimensionas of the world are restricted to two and
  that while the commands to the plannaer are given in plain English, the
  grammar that the scheduler is able to parse is quite simple.

  The application is inspired by the much more complex system described in Terry
  Winograd's PhD thesis \cite{win1970shrdlu}.

\noindent \textbf{Keywords: Automated planning, SHRDLU, PDDL, STRIPS}


\addcontentsline{toc}{section}{Abstract}
#+END_LATEX

\newpage
[TABLE-OF-CONTENTS]
\newpage

\pagenumbering{arabic}

* Introduction and Background
  This section gives an overview about the problem itself and describes the
  algorithms, theorems and tools that were used during this project.
  Furthermore, this section presents several alternative solutions for the
  given problem, that were not used in the final solution, but took part in
  the development process.

** Problem description
   \todo{TODO Describe Block-World, translate grammar -> repr. solvable by some solver }

   The problem consists of the implementation of planner for a robot arm in a
   two-dimensional Shrdlite virtual
   world. This robot arm can only pick up or drop an element at the same time.
   The planner's task is to determine a sequence of the pick-up and drop
   commands that leaves the virtual world in the required state defined by
   the user.

   The block elements have several properties, such us: form, color, size,
   width and height. Depending on these properties, several rules exist
   that exclude certain combinations of stacked objects. For instance, a
   block cannot be placed on another block if it is greater than the other
   block, or nothing can be placed on a ball or pyramid. Besides blocks, there
   is a floor in the world which cannot be moved and nothing can be below it.

   The elements and their positions in the initial world state are chosen
   arbitrarily and hard-coded in the system. This initial state can be set to
   any preferable state.

   A command given by the user is first parsed by a grammar interpreter,
   called GF. Then, before feeding the result to the planner, it must be
   converted to a form that is compatible with the planner. In our case it
   is written in Planning Domain Definition Language. Finally, the planner
   gives back a list of pick and drop commands that provide the transition
   between the current and goal state.
** Related work Bartek
   \todo{TODO Describe some other planners, list some papers, mention FF, hanoi problem}
** Available tools Bartek
   \todo{TODO FOL-theorem proovers, STRIPS, PDDL, GF}

* Overview of the architecture
   This section describes the parts of the project that has been finished,
   currently under development, or just an idea waiting to be implemented.
   Section~\ref{sec:finished} shows a detailed view about the current design
   including the structure of the domain and problem file written in PDDL,
   the code level representation of the world, the goal creation process and
   the interpretation of the parsed grammar tree. Section~\ref{sec:progress}
   mainly contains the user commands that do not work as expected and,
   therefore, these cases are still under investigation. Finally, section
   \ref{sec:future} mentions some of the possibilities for further development.

** Finished work
   \label{sec:finished}

   On a very high level, the implementation consists of three parts:
   - Parsing and simplifying a natural language command from the user
     using /GF/ \cite{gf}.
   - Transforming a world state and a simplified command into a goal
     and then transforming the same world state and goal into a
     /PDDL/-problem.
   - Using the /metric-ff/ planner to extract a plan for the given
     problem.
   The following sections will examine our solutions for each of these
   problems in detail.

*** Parsing
    \label{sec:parsing}

    \todo{talk about GF and the shrdlite grammar?}

*** Goal/Problem generation
    \label{sec:goal-gen}

    \emph{All functions in the following sections belongs to the
    \texttt{Planner} module (if not stated otherwise).}

**** Finding goals
     \todo{We might need an s-expression introduction since we
     talk about s-expressions here.}

     The implementation of the goal finding functions closely follows
     the structure of the /shrdlite/ grammar mentioned in the previous
     section. A parse tree from a user command start with either a
     =take=, =put= or =move= atom where the first two commands has
     exactly one argument, a thing- or a location-description
     respectively. The =move= command is a bit more powerful and takes
     both a thing- and location-description as arguments. The function
     =tryGoal= only matches this first command token and delegates the
     responsibility of producing a goal to =tryTake=, =tryPut= or
     =tryMove= respectively. Below =tryMove= is examined since this is
     enough to understand the implementation of the other two
     functions.
\begin{haskell}
tryMove :: SExpr -> Reader State (Maybe Goal)
tryMove (List [src, List [Atom loc, dst]]) = do
    (_,world) <- ask
    let s = findThings world src
        d = findThings world dst
        qSrc = getQuantifier src
        qDst = getQuantifier dst
        goalList f = [(qSrc (map (thingToBlock . snd) s), qDst (map (f . snd) d))]
    return $ Just $ case loc of
        "beside"  -> defaultGoal { getBeside  = goalList thingToBlock }
        ...
        "inside"  -> defaultGoal { getIn      = goalList thingToBlock }
\end{haskell}
     The sole argument to =tryMove= is an s-expression list containing
     exactly two elements, a thing description and a location
     description. On line 4 =s= will be a list of all things in the
     current world matching the thing description found in =src=. On
     the next line =d= will be a list of all things matching the thing
     description =dst=. Note that we are only interested in finding
     the things matching the thing description (=dst=) of the location
     description (=List [Atom loc, dst]=) and not the things that
     matches the whole location description. This is the case since
     the relative position to any of the things matching =dst= is
     directly encoded in the =Goal= data type using one of the fields
     of the data type as can be seen on lines 10 through 16. Finally
     =getQuantifier= is used to get the quantifier used in the
     construction of the goal.
\begin{haskell}
getQuantifier :: SExpr -> [a] -> Quantifier a
getQuantifier q = case q of
    List (Atom "the" : _) -> \[x] -> The x
    List (Atom "all" : _) -> All
    -- This matches any and floor
    _                     -> Any
\end{haskell}
     Basically =getQuantifier= returns the quantifier used in the user
     command. I.e. if the original command was "put any block on the
     floor" then the quantifier returned would be =Any=.

**** Finding Things, Blocks and Locations
     \todo{Maybe have this chapter before "Finding goals"?}

     There are three basic types in the /shrdlite/ world: /things/,
     /blocks/ and /locations/. A thing is one or many blocks or the
     floor. A block is a either a description of a block consisting of
     a form, a size and a color or a block paired with a location. A
     location is a relative placement description, i.e.
     \hbox{\emph{"left of"}/\emph{"above"}} etc, paired with a thing. As an
     example lets look at the following command string and its
     resulting s-expression after being parsed by GF: $$\text{"the
     white block to the left of any red square"} \Longrightarrow$$
     $$\texttt{(the (thatis (block \_ \_ white) (leftof (any (block
     square \_ red)))))}$$ /the/ is one of the constructors to lift a
     block into a thing[fn:1]. /thatis/ is the constructor which takes
     a block and a location and produces a new block. To find all
     things which matches this description the complete s-expression
     is sent to =findThings=. Since the constructor =the= is used
     there must also be a block description which is sent to
     =findBlocks=.
\begin{haskell}
findBlocks :: World -> SExpr -> [(Col, Thing)]
findBlocks world (List [Atom "thatis", blockDescr, locDescr]) = intersect blocks locs
  where
    blocks = findBlocks world blockDescr
    locs   = findLocations world locDescr
findBlocks world (List [Atom "block", Atom form, Atom size, Atom color]) =
    map (second TBlock) . formFilter . sizeFilter . colFilter $ allBlocks
  where
    allBlocks = getBlocks world
    ...
\end{haskell}
     In this function we find that the top most constructor used is
     =thatis= and we must therefore also have one more block- and
     location description. Recursively calling =findBlocks= with the
     block description =(block _ _ white)= returns all white blocks in
     the current world. Now =findLocations= is called with =(leftof
     (any (block square _ red)))= finding all things which matches
     this particular location description. Finally the intersection of
     the results from the recursive call and the call to
     =findLocations= is the final result of this particular call to
     =findBlocks=.

     As an example consider the case when the parse tree mentioned
     above is given to =findThings= in the world seen in figure
     \ref{fig:shrdlite-small}.

     #+CAPTION: Small shrdlite world with four different blocks.
     #+LABEL: fig:shrdlite-small
     #+ATTR_LATEX: scale=1
     [[./images/smallworld.png]]

     1. =findThings= will only remove the "the" from the parse tree and
       call =findBlocks= with the rest of the tree.
     2. =findBlocks= will recursively call itself with =(block _ _
        white)= and =findLocations= with =(leftof (any (block square _
        red)))=.
        1. =findBlocks (block _ _ white)= will return the two white
           blocks in the world.
        2. =findLocations (leftof (any (block square _ red)))= will
           call =findThings (any (block square _ red))= which in turn
           will return the large red square. Now since the constructor
           used to create the location description is =leftof= all
           things in the world to the left of the returned red block
           will be returned, in this case the white ball and the blue
           rectangle and also two /floor tiles/ will be returned, one
           floor tile right below the two blocks and one tile on the
           empty space to the left of these blocks. The floor tiles
           can be seen as immovable blocks at the bottom of every
           column in the world.
        3. Now finally the intersection of =findBlocks= and
           =findLocations= is the returned value for the top most
           =findBlocks= call. This intersection will contain a list of
           exactly one element, namely the white ball.

     Finally the last function that needs to be explained is
     =findLocations=.

\begin{haskell}
findLocations :: World -> SExpr -> [(Col, Thing)]
findLocations world (List [Atom loc, thingDescr]) =
    let things = findThings world thingDescr
        Atom s = car thingDescr
    in case loc of
        ...
        "leftof"  -> let maxIdxFun = if s == "all" then minimum else maximum
                         idxs   = [0 .. maxIdxFun (map fst things)]
                     in concatMap (allThingsAtCol world) idxs
        ...
\end{haskell}

     At line 3 =things= will be bound to the list of things which
     matches the current thing description. Line 7 to 9 shows the
     particular case when we want to return things to the left of all
     or any of the returned things. When /all/ is used in
     =thingDescr=, the minimum column number is taken from column
     indexes in =map fst things=. If /any/ or /the/ is used than the
     maximum column index is returned instead.[fn:2]

**** Generating a PDDL problem
     $~$

**** Putting it all together
     \todo{Show how an example goal is computed from a command string}

*** Finding a plan
    \label{sec:planning}

** Work in progress
   \label{sec:progress}
   Here, some parts that are still under development are touched upon.
   \todo{TODO describe actions that do not work/work not as expected}

*** Bug corrections
   \todo{TODO}

** Future work
   \todo{TODO E-proover, FOL, FOL->PDDL/STRIPS}
   This section mentions some of the many viable additions for the
   library which might further increase its usability.

* Results and Evaluation
   \todo{TODO problem: "Besides Problem" two reds, blah blah...}

* Discussion and Conclusions
   \todo{TODO Sum up your project, suggest future extensions and improvements.}

\printbibliography

\appendix

\addcontentsline{toc}{section}{Appendix}

\newpage

* Shrdlite PDDL domain file
\begin{haskell}
(define (domain shrdlu)
  (:functions (moves))

  (:predicates (clear ?x)          ;; 'x' is top-most block
               (on ?x ?y)          ;; 'x' is on top of 'y'
               (box ?x)            ;; 'x' is a box
               (inside ?x ?y)      ;; 'x' is inside box 'y'
               (inside-any ?x)     ;; 'x' is inside some box
               (smaller ?x ?y)     ;; 'x' is smaller than 'y'
               (stacked-on ?x ?c)  ;; 'x' is stacked on column 'c'
               (holding-any)       ;; the arm is holding something
               (holding ?x)        ;; 'x' is up in the air
               (frozen ?x)         ;; cant move anything after that
               (above ?x ?y)       ;; 'x' is somewhere above 'y'
               (under ?x ?y)       ;; 'x' is somewhere under 'y'
               (left-of ?x ?y)     ;; 'x' is somewhere left of 'y'
               (right-of ?x ?y)    ;; 'x' is somewhere right of 'y'
               (beside ?x ?y))     ;; 'x' is directly beside 'y'

  (:action pick
   :parameters (?obj ?from ?col)
   :precondition (and (not (frozen ?obj))
                      (not (holding-any))
                      (clear ?obj)
                      (on ?obj ?from)
                      (stacked-on ?obj ?col))
   :effect       (and (holding-any)
                      (holding ?obj)
                      (clear ?from)
                      (not (on ?obj ?from))
                      (not (stacked-on ?obj ?col))
                      (increase (moves) 1)))

  (:action drop
   :parameters (?obj ?to ?col)
   :precondition (and (holding ?obj)
                      (clear ?to)
                      (smaller ?obj ?to)
                      (stacked-on ?to ?col))
   :effect       (and (not (holding-any))
                      (not (holding ?obj))
                      (not (clear ?to))
                      (on ?obj ?to)
                      (stacked-on ?obj ?col)
                      (increase (moves) 1)))

  ;; set the flag that the object is above some other objects
  (:action set-above
   :parameters (?first ?second ?under)
   :precondition (and (on ?first ?second)
                      (above ?second ?under))
   :effect       (and (above ?first ?second)
                      (above ?first ?under)
                      (frozen ?first)))

  ;; Set a flag that a 'first' is below or under 'second' and 'above'
  (:action set-under
   :parameters (?first ?second ?above)
   :precondition (and (on ?second ?first)
                      (under ?second ?above))
   :effect       (and (under ?first ?second)
                      (under ?first ?above)
                      (frozen ?above)))

  ;; `x' and `y' are left- and right of each other if `x' is stacked on a floor column to the left of `y'
  (:action set-left-right
   :parameters (?x ?y ?left-floor ?right-floor)
   :precondition (and (stacked-on ?x ?left-floor)
                      (stacked-on ?y ?right-floor)
                      (right-of ?left-floor ?right-floor))
   :effect       (and (right-of ?x ?y)
                      (left-of  ?y ?x)
                      (frozen ?x)
                      (frozen ?y)))

  ;; `x' and `y' are beside each other if `x' is stacked on a floor column beside of `y'
  (:action set-beside
   :parameters (?x ?y ?left-floor ?right-floor)
   :precondition (and (stacked-on ?x ?left-floor)
                      (stacked-on ?y ?right-floor)
                      (beside ?left-floor ?right-floor))
   :effect       (and (beside ?x ?y)
                      (beside ?y ?x)
                      (frozen ?x)
                      (frozen ?y)))

  ;; `x' is inside `box' if `y' is inside `box' and `x' is on `y'
  (:action set-inside
   :parameters (?x ?y ?box)
   :precondition (and (inside ?y ?box)
                      (on ?x ?y))
   :effect       (and (inside ?x ?box)
                      (frozen ?x)))

)
\end{haskell}

* Individual stories
** Attila Nagy
   Code:
   - move command

   Report:
   - Problem Description section,

** David Spångberg

** Bartolomeus Jankowski
* Other
   \note{Here you include all other information and documentation that
   did not fit into the report in the above sections but that you
   consider too important to leave out.}

* Footnotes

[fn:1] The other two are /any/ and /all/.

[fn:2] If /the/ is used then =things= will have exactly length one and
it doesn't matter if we use =minimum= or =maximum=. However if we have
something like =(leftof floor)=, which is valid according to the
grammar, then this will currently result in a pattern match error on
line 4. To fix this the return type of =findLocations=, and
consequently the return type of all =find*= functions, can for
instance be changed to =Error [(Col, Thing)]= and then a descriptive
error message can be returned instead.
